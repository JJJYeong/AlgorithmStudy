/*
 * # 문제 주소
 * https://www.acmicpc.net/problem/1463
 * 
 * # 문제
 * 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
 * 
 * 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
 * 2. X가 2로 나누어 떨어지면, 2로 나눈다.
 * 3. 1을 뺀다.
 * 
 * 정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
 * 
 * # 제한
 * 시간 제한 : 0.15초, 메모리 제한 : 128 MB
 * 
 * # 입력
 * 첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 정수 N이 주어진다.
 * 
 * # 출력
 * 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.
 * 
 */


/* 까먹어서 예전에 정리해 뒀던 풀이법 다시 가져옴 */

/*
 * 1. DP 중에서 타뷸레이션(상향식 접근) 방식을 사용해 배열 인덱스에 해당 값을 1로 만드는 데 필요한 연산 횟수를 기록한다. 

각 숫자별로 필요한 연산 횟수를 기록할 1차원 배열이 필요하다. 

배열의 각 인덱스에 해당 숫자의 연산 횟수를 기록해야 하기 때문에 배열의 N번째 인덱스까지 접근이 가능해야 한다. 

그래서 N+1 크기의 배열이 필요하다. 

 

2. 연산 횟수를 저장한 배열을 DP라고 하면 

DP[N] 에는 N을 1로 만드는 데 필요한 연산 횟수를 저장한다. 

 

주어지는 N에 문제의 조건들을 적용하면

1) N을 3으로 나누면 N/3이 된다. 

반대로 생각하면 N/3에 3을 곱하면 N이 된다. 

N/3을 1로 만드는 데 필요했던 연산 횟수에 +1 하면 N을 1로 만들기 위한 최종 연산 횟수가 된다. 

 

2) N을 2로 나누면 N/2가 된다.

반대로 생각하면 N/2에 2를 곱하면 N이 된다.

N/2를 1로 만드는 데 필요했던 연산 횟수에 +1 하면 N을 1로 만들기 위한 최종 연산 횟수가 된다.

 

3) N에서 1을 빼면 N-1이 된다. 

반대로 생각하면 N-1에 1을 더하면 N이 된다.

N-1을 1로 만드는 데 필요했던 연산 횟수에 +1 하면 N을 1로 만들기 위한 최종 연산 횟수가 된다.

 

위의 아이디어를 정리하면 N을 1로 만들기 위해 필요한 연산 횟수는 

DP[N] = DP[N/3] + 1 혹은

DP[N] = DP[N/2] + 1 혹은

DP[N] = DP[N-1] + 1

세 가지 중 하나가 될 수 있다.

문제의 조건은 최소 연산 횟수를 구하라는 것이니까 저 셋 중 최소값을 구해야 한다. 

 

3. 상향식 접근방식인 타뷸레이션 방식으로 N의 최소값인 1부터 N까지 횟수 계산을 시작해서

다음 숫자는 몇 번의 연산이 필요한지 더해가는 방식으로 접근할 것이다. 

그런데 1은 1로 만드는 데 필요한 연산 횟수가 0이라는 것을 알고 있다. 

그렇다면 각 숫자의 연산 횟수를 저장할 DP 배열을 생성할 때 모든 원소를 0으로 초기화하면

N이 1일 때 필요한 연산 횟수를 알아내기 위해 연산할 필요가 없다. 

N이 2일 때부터 계산을 해 보면 된다.

반복문으로 DP 배열의 2번째 인덱스부터 계산하면서 연산 횟수의 최소값을 인덱스에 저장한다.
 */

import java.util.*;

public class Main {

	public static void main(String[] args) {

		Scanner s = new Scanner(System.in);
		
		int N = s.nextInt();
		
		// DP[N] = N을 1로 만들기 위한 최소 횟수를 저장한 배열인데 뒤집어 생각하면 
		// DP[N] = 1에 3을 곱하거나 2를 곱하거나 1을 더해서 N으로 만든 최소 횟수라고도 할 수 있다.
		int DP[] = new int[N + 1]; 
		
		for (int i = 2; DP.length > i; i++)
		{
			// DP[i]는 1에서 i를 만드는 데 필요한 최소 횟수가 저장되어 있다.
			// 세가지 연산 중에서 1을 빼는 연산을 반대로 생각하면 i-1 값에 1을 더하면 i를 만들 수 있다.
			// 그래서 DP[i - 1]에 저장된 값에 1을 더해주면 i를 만드는 데 필요한 횟수를 구할 수 있다. 
			DP[i] = DP[i - 1] + 1;  
			
			// 그런데 1을 더한 값이 최소 값인지는 아직 알 수 없기 때문에 3으로 나누는 경우와 2로 나누는 경우도 생각해 봐야 한다.
			// 나누기를 반대로 생각하면 곱하기니까 i/3 or i/2 값에 (i/3)*3 or (i/2)*2 하면 i를 만들 수 있다.
			// DP[i]에는 1을 i로 만들기 위한 최소 횟수가 저장되어 있으니까 DP[i/3] or DP[i/2] 인덱스로 가면 직전값의 최소횟수가 저장되어 있다.
			// 그 횟수에 1을 더해주면 i를 만들기 위한 최소 횟수가 된다. 
			// 문제에서 최소값을 요구하기 때문에 위에서 저장한 1을 더했을 때의 값과 2 혹은 3을 곱했을 때의 값 중 더 작은 것 +1 을 DP[i]에 저장한다.
			// 3으로 나눠본 값보다 2로 나눈 값이 더 적을수도 있기 때문에 if문으로 모든 경우를 확인할 수 있도록 한다.
			if (0 == i % 3)
				DP[i] = Integer.min(DP[i], DP[i / 3] + 1);
			if (0 == i % 2)
				DP[i] = Integer.min(DP[i], DP[i / 2] + 1); 
		}
		
		System.out.println(DP[N]);
		
	}

}
