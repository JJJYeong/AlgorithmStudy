/*
 * # 문제 주소
 * https://www.acmicpc.net/problem/1094
 * 
 * # 문제
 * 지민이는 길이가 64cm인 막대를 가지고 있다. 어느 날, 그는 길이가 Xcm인 막대가 가지고 싶어졌다. 
 * 지민이는 원래 가지고 있던 막대를 더 작은 막대로 자른다음에, 풀로 붙여서 길이가 Xcm인 막대를 만들려고 한다.
 * 
 * 막대를 자르는 가장 쉬운 방법은 절반으로 자르는 것이다. 지민이는 아래와 같은 과정을 거쳐서 막대를 자르려고 한다.
 * 
 * 지민이가 가지고 있는 막대의 길이를 모두 더한다. 처음에는 64cm 막대 하나만 가지고 있다. 이때, 합이 X보다 크다면, 아래와 같은 과정을 반복한다.
 * 1. 가지고 있는 막대 중 길이가 가장 짧은 것을 절반으로 자른다.
 * 2. 만약, 위에서 자른 막대의 절반 중 하나를 버리고 남아있는 막대의 길이의 합이 X보다 크거나 같다면, 위에서 자른 막대의 절반 중 하나를 버린다.
 * 3. 이제, 남아있는 모든 막대를 풀로 붙여서 Xcm를 만든다.
 * 
 * X가 주어졌을 때, 위의 과정을 거친다면, 몇 개의 막대를 풀로 붙여서 Xcm를 만들 수 있는지 구하는 프로그램을 작성하시오.  
 * 
 * # 제한
 * 시간 제한 : 2초, 메모리 제한 : 128 MB
 * 
 * # 입력
 * 첫째 줄에 X가 주어진다. X는 64보다 작거나 같은 자연수이다.
 * 
 * # 출력
 * 문제의 과정을 거친다면, 몇 개의 막대를 풀로 붙여서 Xcm를 만들 수 있는지 출력한다.
 * 
 */

/*
 * # 풀이
 * 문제에서 주어진대로 정해진 길이의 막대기를 만드려면 64cm, 32cm는 막대기 하나만 쓰면 되니까 답이 1이다.
 * 48cm를 만드려면 32cm 막대기 하나에 16cm 막대기를 붙이면 되서 답이 2이다.
 * 23cm를 만드려면 16cm 막대기 하나에 4cm 막대기 하나를 붙이고 2cm 막대기 하나를 붙이고 1cm 막대기 하나를 붙이면 되서 답이 4이다.
 * 
 * 위에서 붙인 막대기의 길이들을 보면 10진수를 2진수로 표현한 비트들을 합친 것과 같다.
 * 즉 64cm는 6번 비트 하나만 켜져 있기 때문에(0100 0000) 필요한 막대기의 개수가 1개이고,
 * 48cm는 5번과 4번 비트가 하나씩 켜져 있기 때문에(0011 0000) 필요한 막대기의 개수가 2개이다.
 * 23cm는 4번 비트와 2번, 1번, 0번 비트가 켜져 있기 때문에(0001 0111) 필요한 막대기의 개수가 4개이다. 
 * 
 * 그렇다는 것은 주어지는 X에서 켜져 있는 비트 수만 세면 막대기가 몇 개 필요한지 알 수 있다는 말이 된다.
 * 반복문으로 0번 비트부터 6번 비트까지 비트연산을 하면서 켜져 있는 비트가 몇 개인지 세면 정답을 구할 수 있다.
 * 
 */

import java.io.*;

public class Main {
	
	static final int MAX_BIT = 6; // 막대기의 최대값인 64는 6번 비트 하나만 켜져 있을 때의 값임

	public static void main(String[] args) throws IOException {
		
		// 입출력 시간을 줄이기 위해 버퍼 입출력 사용
		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		int X = Integer.parseInt(bf.readLine());
		int ans = 0;
		for (int i = 0; MAX_BIT >= i; i++)
		{
			// 1을 i번 왼쪽으로 쉬프트 한 AND 연산의 결과가 0이 아니라면 해당 비트가 켜져 있다는 뜻이다.
			if (0 != (X & (1 << i)))
				ans++;
		}
		
		bw.write(Integer.toString(ans));
		
		bw.close();
		
	}
	
}
